From 360f9e62ac95173ba33f29df6d1eea225204da2a Mon Sep 17 00:00:00 2001
From: Sungbae Yoo <sungbae.yoo@samsung.com>
Date: Fri, 1 Nov 2019 16:43:40 +0900
Subject: [PATCH] Apply CFI on kernel using alternative PAC

Signed-off-by: Sungbae Yoo <sungbae.yoo@samsung.com>

diff --git a/Makefile b/Makefile
index 4dad2d1c24ba..082c9aab9351 100644
--- a/Makefile
+++ b/Makefile
@@ -705,6 +705,52 @@ ifdef CONFIG_CC_STACKPROTECTOR
 endif
 KBUILD_CFLAGS += $(stackp-flag)
 
+ifdef CONFIG_ALTERNATIVE_KPAC
+KPAC_PFLAGS := -fplugin-arg-xcfi-pac-key=none
+endif
+
+ifneq (${KPAC_PFLAGS},)
+KBUILD_CFLAGS += -march=armv8.3-a \
+				-fplugin=$(shell pwd)/../../work-new/paclinux/xcfi/out/xcfi.so \
+				-fplugin-arg-xcfi-no-lto \
+				${KPAC_PFLAGS} \
+				-fno-move-loop-invariants
+KBUILD_AFLAGS += -march=armv8.3-a
+
+# the follows are blacked because they are used in assembly code
+KBUILD_CFLAGS += -fplugin-arg-xcfi-black-target=sys_call_table \
+
+# the follows are blacked because they are used in assembly code
+KBUILD_CFLAGS += -fplugin-arg-xcfi-black-pac=bcm2836_arm_irqchip_handle_irq
+
+# the follows are blacked because they handle pointer from userpace
+KBUILD_CFLAGS += -fplugin-arg-xcfi-black-target=sig_handler \
+				-fplugin-arg-xcfi-black-target=setup_return \
+				-fplugin-arg-xcfi-black-target=compat_setup_return \
+				-fplugin-arg-xcfi-black-target=ignore_signals \
+				-fplugin-arg-xcfi-black-target=flush_signal_handlers \
+				-fplugin-arg-xcfi-black-target=unhandled_signal \
+				-fplugin-arg-xcfi-black-target=force_sig_info \
+				-fplugin-arg-xcfi-black-target=force_sigsegv \
+				-fplugin-arg-xcfi-black-target=do_notify_parent \
+				-fplugin-arg-xcfi-black-target=do_notify_parent_cldstop \
+				-fplugin-arg-xcfi-black-target=get_signal \
+				-fplugin-arg-xcfi-black-target=kernel_sigaction \
+				-fplugin-arg-xcfi-black-target=__arm64_sys_rt_sigaction \
+				-fplugin-arg-xcfi-black-target=__arm64_compat_sys_rt_sigaction \
+				-fplugin-arg-xcfi-black-target=__arm64_compat_sys_sigaction \
+				-fplugin-arg-xcfi-black-target=sigaction \
+				-fplugin-arg-xcfi-black-target=signal \
+				-fplugin-arg-xcfi-black-target=complete_signal \
+				-fplugin-arg-xcfi-black-target=collect_sigign_sigcatch \
+				-fplugin-arg-xcfi-black-target=is_ignored
+endif
+
+ifdef CONFIG_ALTERNATIVE_KPAC_SIGN_RETURN_ADDRESS
+KBUILD_CFLAGS += -march=armv8.3-a
+KBUILD_CFLAGS += -msign-return-address=alt
+endif
+
 ifeq ($(cc-name),clang)
 KBUILD_CPPFLAGS += $(call cc-option,-Qunused-arguments,)
 KBUILD_CFLAGS += $(call cc-disable-warning, format-invalid-specifier)
diff --git a/arch/arm64/configs/tizen_bcmrpi3_defconfig b/arch/arm64/configs/tizen_bcmrpi3_defconfig
index 380618a807d3..74094cfec847 100644
--- a/arch/arm64/configs/tizen_bcmrpi3_defconfig
+++ b/arch/arm64/configs/tizen_bcmrpi3_defconfig
@@ -255,10 +255,10 @@ CONFIG_SECCOMP_FILTER=y
 CONFIG_HAVE_GCC_PLUGINS=y
 # CONFIG_GCC_PLUGINS is not set
 CONFIG_HAVE_CC_STACKPROTECTOR=y
-# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR=y
 CONFIG_CC_STACKPROTECTOR_NONE=y
 # CONFIG_CC_STACKPROTECTOR_REGULAR is not set
-# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_CC_STACKPROTECTOR_STRONG=y
 CONFIG_THIN_ARCHIVES=y
 CONFIG_HAVE_CONTEXT_TRACKING=y
 CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
@@ -686,7 +686,7 @@ CONFIG_INET_TCP_DIAG=y
 CONFIG_TCP_CONG_CUBIC=y
 CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
-CONFIG_IPV6=y
+# CONFIG_IPV6 is not set
 CONFIG_IPV6_ROUTER_PREF=y
 # CONFIG_IPV6_ROUTE_INFO is not set
 # CONFIG_IPV6_OPTIMISTIC_DAD is not set
@@ -4139,6 +4139,8 @@ CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
 #
 # Security options
 #
+CONFIG_ALTERNATIVE_KPAC=y
+CONFIG_ALTERNATIVE_KPAC_SIGN_RETURN_ADDRESS=y
 CONFIG_KEYS=y
 CONFIG_KEYS_COMPAT=y
 # CONFIG_PERSISTENT_KEYRINGS is not set
diff --git a/arch/arm64/kernel/alternative.c b/arch/arm64/kernel/alternative.c
index 5c4bce4ac381..247a599c83b8 100644
--- a/arch/arm64/kernel/alternative.c
+++ b/arch/arm64/kernel/alternative.c
@@ -151,7 +151,7 @@ static void __apply_alternatives(void *alt_region, bool use_linear_alias)
 		if (alt->cpufeature < ARM64_CB_PATCH)
 			alt_cb = patch_alternative;
 		else
-			alt_cb  = ALT_REPL_PTR(alt);
+			alt_cb = voidptr_to_fnptr(ALT_REPL_PTR(alt), typeof(alt_cb));
 
 		alt_cb(alt, origptr, updptr, nr_inst);
 
diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S
index 261f3f88364c..5f51ee29c8ac 100644
--- a/arch/arm64/kernel/head.S
+++ b/arch/arm64/kernel/head.S
@@ -364,6 +364,9 @@ __primary_switched:
 	add	sp, sp, #16
 	mov	x29, #0
 	mov	x30, #0
+#ifdef CONFIG_ALTERNATIVE_KPAC
+	bl	early_pauth_init
+#endif
 	b	start_kernel
 ENDPROC(__primary_switched)
 
diff --git a/arch/arm64/kernel/module.c b/arch/arm64/kernel/module.c
index f469e0435903..f0e97c8768e1 100644
--- a/arch/arm64/kernel/module.c
+++ b/arch/arm64/kernel/module.c
@@ -410,6 +410,38 @@ int apply_relocate_add(Elf64_Shdr *sechdrs,
 	return -ENOEXEC;
 }
 
+#ifdef CONFIG_ALTERNATIVE_KPAC
+typedef void* pac_t;
+typedef struct {
+	pac_t *addr;
+	u64 buildtime_ctx;
+	u64 runtime_ctx;
+} pac_entry_t;
+
+#define IS_IN(a, min, max) ((unsigned long)(a) >= (min) && \
+							(unsigned long)(a) < (max))
+
+void module_pac_finalize(pac_entry_t *pac_table, const size_t size,
+							const struct module *me) {
+	pac_entry_t *pac_start = pac_table;
+	pac_entry_t *pac_end = pac_start + size / sizeof(pac_entry_t);
+
+	pac_entry_t *ppac;
+
+	for (ppac = pac_start; ppac < pac_end; ppac++) {
+		pac_t addr = *ppac->addr;
+		__asm__ __volatile__("EOR %0, %0, #0xffff0000\n"
+								"EOR %0, %0, #0x00001ff0\n"
+								"EOR %0, %0, #0x03000000\n"
+								"EOR %0, %0, %1\n"
+								: "=&r"(addr)
+								: "r"(ppac->buildtime_ctx ^ ppac->runtime_ctx),
+									"0"(addr));
+		*ppac->addr = addr;
+	}
+}
+#endif
+
 int module_finalize(const Elf_Ehdr *hdr,
 		    const Elf_Shdr *sechdrs,
 		    struct module *me)
@@ -425,6 +457,13 @@ int module_finalize(const Elf_Ehdr *hdr,
 		if (IS_ENABLED(CONFIG_DYNAMIC_FTRACE) &&
 		    !strcmp(".text.ftrace_trampoline", secstrs + s->sh_name))
 			me->arch.ftrace_trampoline = (void *)s->sh_addr;
+#endif
+#ifdef CONFIG_ALTERNATIVE_KPAC
+		if (strcmp(".pac.table", secstrs + s->sh_name) == 0) {
+			preempt_disable();
+			module_pac_finalize((pac_entry_t*)s->sh_addr, s->sh_size, me);
+			preempt_enable();
+		}
 #endif
 	}
 
diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c
index d4b740538ad5..04ff35279a1e 100644
--- a/arch/arm64/kernel/setup.c
+++ b/arch/arm64/kernel/setup.c
@@ -242,6 +242,35 @@ static void __init request_standard_resources(void)
 
 u64 __cpu_logical_map[NR_CPUS] = { [0 ... NR_CPUS-1] = INVALID_HWID };
 
+#ifdef CONFIG_ALTERNATIVE_KPAC
+typedef void* pac_t;
+typedef struct {
+	pac_t *addr;
+	u64 buildtime_ctx;
+	u64 runtime_ctx;
+} pac_entry_t;
+
+extern pac_entry_t __pac_start[];
+extern pac_entry_t __pac_end[];
+
+void __init early_pauth_init(void)
+{
+	pac_entry_t *ppac;
+	for (ppac = __pac_start; ppac < __pac_end; ppac++) {
+		pac_t addr = *ppac->addr;
+		__asm__ __volatile__("EOR %0, %0, #0xffff0000\n"
+								"EOR %0, %0, #0x00001ff0\n"
+								"EOR %0, %0, #0x03000000\n"
+								"EOR %0, %0, %1\n"
+								: "=&r"(addr)
+								: "r"(ppac->buildtime_ctx ^ ppac->runtime_ctx),
+									"0"(addr));
+		*ppac->addr = addr;
+	}
+}
+
+#endif
+
 void __init setup_arch(char **cmdline_p)
 {
 	pr_info("Boot CPU: AArch64 Processor [%08x]\n", read_cpuid_id());
diff --git a/arch/arm64/kernel/vmlinux.lds.S b/arch/arm64/kernel/vmlinux.lds.S
index ddfd3c0942f7..b24e57eaadd2 100644
--- a/arch/arm64/kernel/vmlinux.lds.S
+++ b/arch/arm64/kernel/vmlinux.lds.S
@@ -131,6 +131,15 @@ SECTIONS
 		*(.got)			/* Global offset table		*/
 	}
 
+#ifdef CONFIG_ALTERNATIVE_KPAC
+	.pac.data : {
+		__pac_start = .;
+		KEEP(*(.pac.table))
+		__pac_end = .;
+	}
+#endif
+
+
 	. = ALIGN(SEGMENT_ALIGN);
 	_etext = .;			/* End of text section */
 
diff --git a/crypto/drbg.c b/crypto/drbg.c
index 6c3221313753..128c29f608e2 100644
--- a/crypto/drbg.c
+++ b/crypto/drbg.c
@@ -1985,7 +1985,7 @@ static struct rng_alg drbg_algs[22];
  * with the kernel crypto API. To fill the array, the information
  * from drbg_cores[] is used.
  */
-static inline void __init drbg_fill_array(struct rng_alg *alg,
+static void __init drbg_fill_array(struct rng_alg *alg,
 					  const struct drbg_core *core, int pr)
 {
 	int pos = 0;
diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index b2b1eece0db1..fdfe282f4b64 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -18,10 +18,11 @@
 
 typedef int (*pm_callback_t)(struct device *);
 
-static pm_callback_t __rpm_get_callback(struct device *dev, size_t cb_offset)
+static const struct dev_pm_ops *__rpm_get_pm_ops(struct device *dev,
+													size_t cb_offset)
 {
-	pm_callback_t cb;
 	const struct dev_pm_ops *ops;
+	void *cb;
 
 	if (dev->pm_domain)
 		ops = &dev->pm_domain->ops;
@@ -35,18 +36,19 @@ static pm_callback_t __rpm_get_callback(struct device *dev, size_t cb_offset)
 		ops = NULL;
 
 	if (ops)
-		cb = *(pm_callback_t *)((void *)ops + cb_offset);
+		cb = *((void**)ops + cb_offset);
 	else
 		cb = NULL;
 
 	if (!cb && dev->driver && dev->driver->pm)
-		cb = *(pm_callback_t *)((void *)dev->driver->pm + cb_offset);
+		ops = dev->driver->pm;
 
-	return cb;
+	return ops;
 }
 
 #define RPM_GET_CALLBACK(dev, callback) \
-		__rpm_get_callback(dev, offsetof(struct dev_pm_ops, callback))
+		(__rpm_get_pm_ops(dev, offsetof(struct dev_pm_ops, callback)) \
+			->callback)
 
 static int rpm_resume(struct device *dev, int rpmflags);
 static int rpm_suspend(struct device *dev, int rpmflags);
diff --git a/drivers/clk/bcm/clk-bcm2835.c b/drivers/clk/bcm/clk-bcm2835.c
index ac8ba1888c33..1048ed6c6bd1 100644
--- a/drivers/clk/bcm/clk-bcm2835.c
+++ b/drivers/clk/bcm/clk-bcm2835.c
@@ -1360,12 +1360,15 @@ static const struct clk_ops bcm2835_vpu_clock_clk_ops = {
 static bool bcm2835_clk_is_claimed(const char *name);
 
 static struct clk_hw *bcm2835_register_pll(struct bcm2835_cprman *cprman,
-					   const struct bcm2835_pll_data *data)
+					   const void *d)
 {
+	const struct bcm2835_pll_data *data;
 	struct bcm2835_pll *pll;
 	struct clk_init_data init;
 	int ret;
 
+	data = (const struct bcm2835_pll_data *)d;
+
 	memset(&init, 0, sizeof(init));
 
 	/* All of the PLLs derive from the external oscillator. */
@@ -1394,13 +1397,16 @@ static struct clk_hw *bcm2835_register_pll(struct bcm2835_cprman *cprman,
 
 static struct clk_hw *
 bcm2835_register_pll_divider(struct bcm2835_cprman *cprman,
-			     const struct bcm2835_pll_divider_data *data)
+			     const void *d)
 {
 	struct bcm2835_pll_divider *divider;
+	const struct bcm2835_pll_divider_data *data;
 	struct clk_init_data init;
 	const char *divider_name;
 	int ret;
 
+	data = (const struct bcm2835_pll_divider_data *)d;
+
 	if (data->fixed_divider != 1) {
 		divider_name = devm_kasprintf(cprman->dev, GFP_KERNEL,
 					      "%s_prediv", data->name);
@@ -1460,14 +1466,17 @@ bcm2835_register_pll_divider(struct bcm2835_cprman *cprman,
 }
 
 static struct clk_hw *bcm2835_register_clock(struct bcm2835_cprman *cprman,
-					  const struct bcm2835_clock_data *data)
+					  const void *d)
 {
+	const struct bcm2835_clock_data *data;
 	struct bcm2835_clock *clock;
 	struct clk_init_data init;
 	const char *parents[1 << CM_SRC_BITS];
 	size_t i, j;
 	int ret;
 
+	data = (const struct bcm2835_clock_data *)d;
+
 	/*
 	 * Replace our strings referencing parent clocks with the
 	 * actual clock-output-name of the parent.
@@ -1532,10 +1541,13 @@ static struct clk_hw *bcm2835_register_clock(struct bcm2835_cprman *cprman,
 	return &clock->hw;
 }
 
-static struct clk *bcm2835_register_gate(struct bcm2835_cprman *cprman,
-					 const struct bcm2835_gate_data *data)
+static struct clk_hw *bcm2835_register_gate(struct bcm2835_cprman *cprman,
+					 const void *d)
 {
-	return clk_register_gate(cprman->dev, data->name, data->parent,
+	const struct bcm2835_gate_data *data;
+	data = (const struct bcm2835_gate_data *)d;
+	return (struct clk_hw*)clk_register_gate(cprman->dev,
+				 data->name, data->parent,
 				 CLK_IGNORE_UNUSED | CLK_SET_RATE_GATE,
 				 cprman->regs + data->ctl_reg,
 				 CM_GATE_BIT, 0, &cprman->regs_lock);
diff --git a/drivers/gpu/drm/vc4/vc4_drv.c b/drivers/gpu/drm/vc4/vc4_drv.c
index 1411374a1c6f..bd59abcaa82f 100644
--- a/drivers/gpu/drm/vc4/vc4_drv.c
+++ b/drivers/gpu/drm/vc4/vc4_drv.c
@@ -234,6 +234,13 @@ static int compare_dev(struct device *dev, void *data)
 	return dev == data;
 }
 
+static int vc4_platform_bus_type_match(struct device *dev,
+									void *data)
+{
+	struct device_driver *drv = (struct device_driver *)data;
+	return platform_bus_type.match(dev, drv);
+}
+
 static void vc4_match_add_drivers(struct device *dev,
 				  struct component_match **match,
 				  struct platform_driver *const *drivers,
@@ -246,7 +253,7 @@ static void vc4_match_add_drivers(struct device *dev,
 		struct device *p = NULL, *d;
 
 		while ((d = bus_find_device(&platform_bus_type, p, drv,
-					    (void *)platform_bus_type.match))) {
+					 vc4_platform_bus_type_match))) {
 			put_device(p);
 			component_match_add(dev, match, compare_dev, d);
 			p = d;
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index a704d032713b..b46d44bf7b9f 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -269,6 +269,38 @@ static __always_inline void __write_once_size(volatile void *p, void *res, int s
 
 #endif /* __KERNEL__ */
 
+#define voidptr_to_fnptr(p, type) \
+	({ \
+		void *__voidptr = (void*)(p); \
+		unsigned long __void = (__force unsigned long)__voidptr; \
+		(__force type) __void; \
+	})
+
+#define fnptr_to_voidptr(f) \
+	({ \
+		unsigned long __void = (__force unsigned long)(f); \
+		void *__voidptr = (__forcevoid*)(__void); \
+		(__force typeof(f)) __voidptr; \
+	})
+
+#define convert_to_fnptr(p) \
+	{ \
+		void **__pvoidptr = (__force void**)&(p); \
+		unsigned long __void = (__force unsigned long)*__pvoidptr; \
+		p = (__force typeof(p)) __void; \
+	}
+
+#define convert_to_voidptr(f) \
+	{ \
+		unsigned long __void = (__force unsigned long)(f); \
+		void **__pvoidptr = (__force void**)&(f); \
+		*__pvoidptr = (__force void*)(__void); \
+	}
+
+unsigned long __builtin_pac_get_context(unsigned long, ...);
+
+#define pac_bind(hint, ...) __attribute__((pacbind(hint, __VA_ARGS__)))
+
 #endif /* __ASSEMBLY__ */
 
 #ifndef __optimize
diff --git a/include/linux/cpuidle.h b/include/linux/cpuidle.h
index a6989e02d0a0..8c66ad67ad63 100644
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@ -56,7 +56,7 @@ struct cpuidle_state {
 	 * suspended, so it must not re-enable interrupts at any point (even
 	 * temporarily) or attempt to change states of clock event devices.
 	 */
-	void (*enter_s2idle) (struct cpuidle_device *dev,
+	int (*enter_s2idle) (struct cpuidle_device *dev,
 			      struct cpuidle_driver *drv,
 			      int index);
 };
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 69c238210325..6d1fd45bd19f 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -123,7 +123,11 @@ struct irqaction {
 	unsigned long		thread_mask;
 	const char		*name;
 	struct proc_dir_entry	*dir;
+#ifdef CONFIG_ALTERNATIVE_KPAC
+} ____cacheline_internodealigned_in_smp pac_bind("&handler", "handler");
+#else
 } ____cacheline_internodealigned_in_smp;
+#endif
 
 extern irqreturn_t no_action(int cpl, void *dev_id);
 
diff --git a/include/linux/smp.h b/include/linux/smp.h
index 9fb239e12b82..9a7c1d9f0e7f 100644
--- a/include/linux/smp.h
+++ b/include/linux/smp.h
@@ -20,7 +20,11 @@ struct __call_single_data {
 	smp_call_func_t func;
 	void *info;
 	unsigned int flags;
+#ifdef CONFIG_ALTERNATIVE_KPAC
+} pac_bind("info", "func");
+#else
 };
+#endif
 
 /* Use __aligned() to avoid to use 2 cache lines for 1 csd */
 typedef struct __call_single_data call_single_data_t
diff --git a/include/linux/types.h b/include/linux/types.h
index 34fce54e4f1b..65b844a7c8a6 100644
--- a/include/linux/types.h
+++ b/include/linux/types.h
@@ -223,7 +223,11 @@ struct ustat {
 struct callback_head {
 	struct callback_head *next;
 	void (*func)(struct callback_head *head);
+#if CONFIG_ALTERNATIVE_KPAC
+} __attribute__((aligned(sizeof(void *)))) __attribute__((pacbind("&func", "func")));
+#else
 } __attribute__((aligned(sizeof(void *))));
+#endif
 #define rcu_head callback_head
 
 typedef void (*rcu_callback_t)(struct rcu_head *head);
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 069311541577..83fb0bae05d5 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -1049,11 +1049,11 @@ static int irq_setup_forced_threading(struct irqaction *new)
 		new->secondary = kzalloc(sizeof(struct irqaction), GFP_KERNEL);
 		if (!new->secondary)
 			return -ENOMEM;
-		new->secondary->handler = irq_forced_secondary_handler;
 		new->secondary->thread_fn = new->thread_fn;
 		new->secondary->dev_id = new->dev_id;
 		new->secondary->irq = new->irq;
 		new->secondary->name = new->name;
+		new->secondary->handler = irq_forced_secondary_handler;
 	}
 	/* Deal with the primary handler */
 	set_bit(IRQTF_FORCED_THREAD, &new->thread_flags);
@@ -1773,11 +1773,11 @@ int request_threaded_irq(unsigned int irq, irq_handler_t handler,
 	if (!action)
 		return -ENOMEM;
 
-	action->handler = handler;
 	action->thread_fn = thread_fn;
 	action->flags = irqflags;
 	action->name = devname;
 	action->dev_id = dev_id;
+	action->handler = handler;
 
 	retval = irq_chip_pm_get(&desc->irq_data);
 	if (retval < 0) {
@@ -2081,10 +2081,10 @@ int __request_percpu_irq(unsigned int irq, irq_handler_t handler,
 	if (!action)
 		return -ENOMEM;
 
-	action->handler = handler;
 	action->flags = flags | IRQF_PERCPU | IRQF_NO_SUSPEND;
 	action->name = devname;
 	action->percpu_dev_id = dev_id;
+	action->handler = handler;
 
 	retval = irq_chip_pm_get(&desc->irq_data);
 	if (retval < 0) {
diff --git a/kernel/smp.c b/kernel/smp.c
index 2d1da290f144..8bd1e26e2a50 100644
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@ -161,8 +161,8 @@ static int generic_exec_single(int cpu, call_single_data_t *csd,
 		return -ENXIO;
 	}
 
-	csd->func = func;
 	csd->info = info;
+	csd->func = func;
 
 	/*
 	 * The list addition should be visible before sending the IPI
@@ -451,8 +451,8 @@ void smp_call_function_many(const struct cpumask *mask,
 		csd_lock(csd);
 		if (wait)
 			csd->flags |= CSD_FLAG_SYNCHRONOUS;
-		csd->func = func;
 		csd->info = info;
+		csd->func = func;
 		if (llist_add(&csd->llist, &per_cpu(call_single_queue, cpu)))
 			__cpumask_set_cpu(cpu, cfd->cpumask_ipi);
 	}
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 57fc13c6ab2b..849ebac6f6c7 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -331,7 +331,7 @@ static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
 		int protocol = iph->protocol;
 
 		ipprot = rcu_dereference(inet_protos[protocol]);
-		if (ipprot && (edemux = READ_ONCE(ipprot->early_demux))) {
+		if (ipprot && (edemux = ipprot->early_demux)) {
 			err = edemux(skb);
 			if (unlikely(err))
 				goto drop_error;
diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c
index 9ee208a348f5..b243523ca2ef 100644
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -62,7 +62,7 @@ int ip6_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
 		const struct inet6_protocol *ipprot;
 
 		ipprot = rcu_dereference(inet6_protos[ipv6_hdr(skb)->nexthdr]);
-		if (ipprot && (edemux = READ_ONCE(ipprot->early_demux)))
+		if (ipprot && (edemux = ipprot->early_demux))
 			edemux(skb);
 	}
 	if (!skb_valid_dst(skb))
diff --git a/security/Kconfig b/security/Kconfig
index 87f2a6f842fd..b50e5648d6c8 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -263,5 +263,33 @@ config DEFAULT_SECURITY
 	default "apparmor" if DEFAULT_SECURITY_APPARMOR
 	default "" if DEFAULT_SECURITY_DAC
 
+config ALTERNATIVE_KPAC
+	bool "Enable an alternative of ARM's PAC for Linux"
+	depends on !ARM64_PTR_AUTH
+	depends on ARM64
+	help
+	  This enables an alternative of ARM PAC,
+	  which uses a kind of anlalgoues of PAC operations.
+	  In the other words, it does not use real PAC operations.
+	  It can be used on the machine does not have ARM PAC support
+
+	  But it is totally unsafe because it does not have sophiscated
+	  authentication model using secure keys.
+
+	  If you are unsure how to answer this question, answer N.
+
+config ALTERNATIVE_KPAC_SIGN_RETURN_ADDRESS
+	bool "Enable an alternative of ARM's Signing return address for Linux"
+	depends on !ARM64_PTR_AUTH
+	depends on ARM64
+#	depends on $(cc-option,-msign-return-address=alt)
+	depends on STACKPROTECTOR_STRONG
+	depends on STACKPROTECTOR
+	help
+	  This enables -msign-return-address=alt in gcc.
+
+	  If you are unsure how to answer this question, answer N.
+
 endmenu
 
+
-- 
2.17.1

